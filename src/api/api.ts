/* tslint:disable */
/* eslint-disable */
/**
 * Благотворительное приложение API
 * API для благотворительного приложения \"Помощь\"
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration.ts';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.ts';
import type { RequestArgs } from './base.ts';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base.ts';

export interface MainChangePasswordRequest {
    'new_password': string;
    'old_password': string;
}
export interface MainChatResponse {
    'created_at'?: string;
    'helper_id'?: number;
    'id'?: number;
    'needy_id'?: number;
    'post_id'?: number;
}
export interface MainChatWithDetails {
    'created_at'?: string;
    'helper_id'?: number;
    'id'?: number;
    'interlocutor'?: MainUserInfo;
    'last_message'?: MainMessage;
    'needy_id'?: number;
    'post'?: MainPostWithDetails;
    'post_id'?: number;
    'unread_count'?: number;
    'updated_at'?: string;
}
export interface MainChatsListResponse {
    'data'?: Array<MainChatWithDetails>;
}
export interface MainCreateChatRequest {
    'post_id': number;
}
export interface MainDonationResponse {
    'amount'?: number;
    'created_at'?: string;
    'donor_id'?: number;
    'id'?: number;
    'post_id'?: number;
    'receipt_url'?: string;
    'status'?: string;
}
export interface MainDonationUpdateResponse {
    'confirmed_at'?: string;
    'confirmed_by'?: number;
    'id'?: number;
    'status'?: string;
}
export interface MainDonationWithDetails {
    'amount'?: number;
    'confirmed_at'?: string;
    'confirmed_by'?: number;
    'created_at'?: string;
    'donor'?: MainUserInfo;
    'donor_id'?: number;
    'id'?: number;
    'post'?: MainPostInfo;
    'post_id'?: number;
    'receipt_url'?: string;
    'status'?: string;
}
export interface MainDonationsListResponse {
    'data'?: Array<MainDonationWithDetails>;
    'pagination'?: MainPaginationResponse;
}
export interface MainErrorDetail {
    'code'?: string;
    'details'?: { [key: string]: any; };
    'message'?: string;
}
export interface MainErrorResponse {
    'error'?: MainErrorDetail;
}
export interface MainHealthCheckResponse {
    'database'?: string;
    'minio'?: string;
    'status'?: string;
    'timestamp'?: string;
}
export interface MainLoginRequest {
    'password': string;
    'phone': string;
}
export interface MainLoginResponse {
    'token'?: string;
    'user'?: MainUser;
    'user_id'?: number;
}
export interface MainMarkMessagesReadRequest {
    'message_ids'?: Array<number>;
}
export interface MainMarkMessagesReadResponse {
    'message'?: string;
    'updated_count'?: number;
}
export interface MainMessage {
    'attachment_url'?: string;
    'chat_id'?: number;
    'created_at'?: string;
    'id'?: number;
    'is_edited'?: boolean;
    'is_read'?: boolean;
    'sender_id'?: number;
    'text'?: string;
    'updated_at'?: string;
}
export interface MainMessageResponse {
    'attachment_url'?: string;
    'chat_id'?: number;
    'created_at'?: string;
    'id'?: number;
    'is_edited'?: boolean;
    'is_read'?: boolean;
    'sender_id'?: number;
    'text'?: string;
}
export interface MainMessageUpdateResponse {
    'id'?: number;
    'is_edited'?: boolean;
    'text'?: string;
    'updated_at'?: string;
}
export interface MainMessageWithDetails {
    'attachment_url'?: string;
    'chat_id'?: number;
    'created_at'?: string;
    'id'?: number;
    'is_edited'?: boolean;
    'is_read'?: boolean;
    'sender'?: MainUserInfo;
    'sender_id'?: number;
    'text'?: string;
    'updated_at'?: string;
}
export interface MainMessagesListResponse {
    'data'?: Array<MainMessageWithDetails>;
    'pagination'?: MainPaginationResponse;
}
export interface MainPaginationResponse {
    'limit'?: number;
    'page'?: number;
    'total'?: number;
    'total_pages'?: number;
}
export interface MainPhotoUploadResponse {
    'photo_url'?: string;
}
export interface MainPostInfo {
    'amount'?: number;
    'collected'?: number;
    'id'?: number;
    'title'?: string;
}
export interface MainPostMedia {
    'created_at'?: string;
    'id'?: number;
    'media_type'?: string;
    'media_url'?: string;
    'order_index'?: number;
    'post_id'?: number;
}
export interface MainPostResponse {
    'amount'?: number;
    'collected'?: number;
    'created_at'?: string;
    'description'?: string;
    'id'?: number;
    'status'?: string;
    'title'?: string;
    'updated_at'?: string;
    'user_id'?: number;
}
export interface MainPostUpdateResponse {
    'id'?: number;
    'title'?: string;
    'updated_at'?: string;
}
export interface MainPostWithDetails {
    'amount'?: number;
    'author'?: MainUserInfo;
    'bank'?: string;
    'collected'?: number;
    'created_at'?: string;
    'description'?: string;
    'id'?: number;
    'is_editable'?: boolean;
    'media'?: Array<MainPostMedia>;
    'phone'?: string;
    'recipient'?: string;
    'status'?: string;
    'title'?: string;
    'updated_at'?: string;
    'user_id'?: number;
}
export interface MainPostsListResponse {
    'data'?: Array<MainPostWithDetails>;
    'pagination'?: MainPaginationResponse;
}
export interface MainPresignedGetURLRequest {
    'bucket': string;
    /**
     * max 7 days
     */
    'expires_in'?: number;
    'object_key': string;
}
export interface MainPresignedGetURLResponse {
    'expires_at'?: string;
    'url'?: string;
}
export interface MainPresignedURLRequest {
    'bucket': string;
    'content_type': string;
    /**
     * max 7 days
     */
    'expires_in'?: number;
    'object_key': string;
}
export interface MainPresignedURLResponse {
    'expires_at'?: string;
    'object_url'?: string;
    'upload_url'?: string;
}
export interface MainRatingWithDetails {
    'id'?: number;
    'points'?: number;
    'position'?: number;
    'status'?: string;
    'total_donated'?: number;
    'updated_at'?: string;
    'user'?: MainUserInfo;
    'user_id'?: number;
}
export interface MainRatingsListResponse {
    'data'?: Array<MainRatingWithDetails>;
    'pagination'?: MainPaginationResponse;
}
export interface MainRefreshTokenResponse {
    'token'?: string;
}
export interface MainRegisterRequest {
    'first_name': string;
    'last_name': string;
    'password': string;
    'phone': string;
}
export interface MainRegisterResponse {
    'message'?: string;
    'token'?: string;
    'user_id'?: number;
}
export interface MainSuccessResponse {
    'message'?: string;
}
export interface MainUpdateDonationRequest {
    'status': MainUpdateDonationRequestStatusEnum;
}

export const MainUpdateDonationRequestStatusEnum = {
    Confirmed: 'confirmed',
    Rejected: 'rejected'
} as const;

export type MainUpdateDonationRequestStatusEnum = typeof MainUpdateDonationRequestStatusEnum[keyof typeof MainUpdateDonationRequestStatusEnum];

export interface MainUpdateMessageRequest {
    'text': string;
}
export interface MainUpdatePostRequest {
    'amount'?: number;
    'bank'?: string;
    'description'?: string;
    'phone'?: string;
    'recipient'?: string;
    'title'?: string;
}
export interface MainUpdateProfileRequest {
    'first_name'?: string;
    'helper_name'?: string;
    'last_name'?: string;
}
export interface MainUpdateVerificationRequest {
    'rejection_reason'?: string;
    'status': MainUpdateVerificationRequestStatusEnum;
}

export const MainUpdateVerificationRequestStatusEnum = {
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type MainUpdateVerificationRequestStatusEnum = typeof MainUpdateVerificationRequestStatusEnum[keyof typeof MainUpdateVerificationRequestStatusEnum];

export interface MainUser {
    'created_at'?: string;
    'first_name'?: string;
    'helper_name'?: string;
    'id'?: number;
    'is_active'?: boolean;
    'last_name'?: string;
    'phone'?: string;
    'photo_url'?: string;
    'role'?: string;
    'updated_at'?: string;
}
export interface MainUserInfo {
    'avatar'?: string;
    'id'?: number;
    'name'?: string;
}
export interface MainVerification {
    'birth_date'?: string;
    'consent1'?: boolean;
    'consent2'?: boolean;
    'consent3'?: boolean;
    'doc_type'?: string;
    'first_name'?: string;
    'id'?: number;
    'inn'?: string;
    'last_name'?: string;
    'middle_name'?: string;
    'passport_date'?: string;
    'passport_issuer'?: string;
    'passport_number'?: string;
    'passport_scans_urls'?: Array<string>;
    'passport_series'?: string;
    'rejection_reason'?: string;
    'reviewed_at'?: string;
    'reviewed_by'?: number;
    'snils'?: string;
    'status'?: string;
    'submitted_at'?: string;
    'user_id'?: number;
    'user_photo_url'?: string;
}
export interface MainVerificationResponse {
    'id'?: number;
    'message'?: string;
    'rejection_reason'?: string;
    'reviewed_at'?: string;
    'reviewed_by'?: number;
    'status'?: string;
    'submitted_at'?: string;
    'user_id'?: number;
}
export interface MainVerificationsListResponse {
    'data'?: Array<MainVerification>;
    'pagination'?: MainPaginationResponse;
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Аутентифицирует пользователя и возвращает JWT токен
         * @summary Вход в систему
         * @param {MainLoginRequest} request Данные входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (request: MainLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authLoginPost', 'request', request)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет JWT токен пользователя
         * @summary Обновление токена
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Регистрирует нового пользователя в системе
         * @summary Регистрация пользователя
         * @param {MainRegisterRequest} request Данные регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (request: MainRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authRegisterPost', 'request', request)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список всех чатов текущего пользователя
         * @summary Получить список чатов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список сообщений в чате с пагинацией
         * @summary Получить сообщения чата
         * @param {number} id ID чата
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество сообщений
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesGet: async (id: number, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdMessagesGet', 'id', id)
            const localVarPath = `/chats/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет сообщение из чата (только отправитель может удалить)
         * @summary Удалить сообщение
         * @param {number} id ID чата
         * @param {number} messageId ID сообщения
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesMessageIdDelete: async (id: number, messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdMessagesMessageIdDelete', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('chatsIdMessagesMessageIdDelete', 'messageId', messageId)
            const localVarPath = `/chats/{id}/messages/{message_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Редактирует текст сообщения (только отправитель может редактировать)
         * @summary Редактировать сообщение
         * @param {number} id ID чата
         * @param {number} messageId ID сообщения
         * @param {MainUpdateMessageRequest} request Новый текст
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesMessageIdPatch: async (id: number, messageId: number, request: MainUpdateMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdMessagesMessageIdPatch', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('chatsIdMessagesMessageIdPatch', 'messageId', messageId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('chatsIdMessagesMessageIdPatch', 'request', request)
            const localVarPath = `/chats/{id}/messages/{message_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет новое сообщение в чат (текст или вложение)
         * @summary Отправить сообщение
         * @param {number} id ID чата
         * @param {string} [text] Текст сообщения
         * @param {File} [attachment] Вложение (изображение, до 5MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesPost: async (id: number, text?: string, attachment?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdMessagesPost', 'id', id)
            const localVarPath = `/chats/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (text !== undefined) { 
                localVarFormParams.append('text', text as any);
            }
    
            if (attachment !== undefined) { 
                localVarFormParams.append('attachment', attachment as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отмечает сообщения в чате как прочитанные
         * @summary Отметить сообщения как прочитанные
         * @param {number} id ID чата
         * @param {MainMarkMessagesReadRequest} [request] ID сообщений (опционально, если пусто - все сообщения)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesReadPatch: async (id: number, request?: MainMarkMessagesReadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdMessagesReadPatch', 'id', id)
            const localVarPath = `/chats/{id}/messages/read`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новый чат между помощником и нуждающимся по посту
         * @summary Создать чат
         * @param {MainCreateChatRequest} request ID поста
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPost: async (request: MainCreateChatRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('chatsPost', 'request', request)
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список пожертвований с фильтрацией и пагинацией
         * @summary Получить список пожертвований
         * @param {number} [postId] Фильтр по посту
         * @param {number} [donorId] Фильтр по донору
         * @param {DonationsGetStatusEnum} [status] Фильтр по статусу
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        donationsGet: async (postId?: number, donorId?: number, status?: DonationsGetStatusEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/donations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postId !== undefined) {
                localVarQueryParameter['post_id'] = postId;
            }

            if (donorId !== undefined) {
                localVarQueryParameter['donor_id'] = donorId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает детальную информацию о пожертвовании
         * @summary Получить пожертвование
         * @param {number} id ID пожертвования
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        donationsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('donationsIdGet', 'id', id)
            const localVarPath = `/donations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет статус пожертвования (подтвердить или отклонить)
         * @summary Подтвердить/отклонить пожертвование
         * @param {number} id ID пожертвования
         * @param {MainUpdateDonationRequest} request Статус
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        donationsIdPatch: async (id: number, request: MainUpdateDonationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('donationsIdPatch', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('donationsIdPatch', 'request', request)
            const localVarPath = `/donations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новое пожертвование для поста
         * @summary Создать пожертвование
         * @param {number} postId ID поста
         * @param {number} amount Сумма пожертвования
         * @param {File} [receipt] Чек/скриншот (JPEG, PNG, PDF, до 10MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        donationsPost: async (postId: number, amount: number, receipt?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('donationsPost', 'postId', postId)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('donationsPost', 'amount', amount)
            const localVarPath = `/donations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (postId !== undefined) { 
                localVarFormParams.append('post_id', postId as any);
            }
    
            if (amount !== undefined) { 
                localVarFormParams.append('amount', amount as any);
            }
    
            if (receipt !== undefined) { 
                localVarFormParams.append('receipt', receipt as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает файл из MinIO и отдает его клиенту (проксирование). Путь к файлу может содержать слэши, например: /files/user-photos/users/1/photo.jpg
         * @summary Получить файл
         * @param {string} bucket Название bucket
         * @param {string} objectKey Ключ объекта (путь к файлу, может содержать слэши)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesBucketObjectKeyGet: async (bucket: string, objectKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bucket' is not null or undefined
            assertParamExists('filesBucketObjectKeyGet', 'bucket', bucket)
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('filesBucketObjectKeyGet', 'objectKey', objectKey)
            const localVarPath = `/files/{bucket}/{objectKey}`
                .replace(`{${"bucket"}}`, encodeURIComponent(String(bucket)))
                .replace(`{${"objectKey"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Генерирует presigned URL для чтения (скачивания) файла из MinIO
         * @summary Получить presigned URL для чтения
         * @param {MainPresignedGetURLRequest} request Параметры запроса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPresignedUrlPost: async (request: MainPresignedGetURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('filesPresignedUrlPost', 'request', request)
            const localVarPath = `/files/presigned-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Проверяет состояние сервера, подключение к базе данных и MinIO
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список постов с пагинацией и фильтрацией
         * @summary Получить список постов
         * @param {PostsGetStatusEnum} [status] Фильтр по статусу
         * @param {number} [userId] Фильтр по автору
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsGet: async (status?: PostsGetStatusEnum, userId?: number, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет пост (только автор может удалить)
         * @summary Удалить пост
         * @param {number} id ID поста
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postsIdDelete', 'id', id)
            const localVarPath = `/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает детальную информацию о посте
         * @summary Получить пост
         * @param {number} id ID поста
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postsIdGet', 'id', id)
            const localVarPath = `/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет медиа файл из поста
         * @summary Удалить медиа из поста
         * @param {number} id ID поста
         * @param {number} mediaId ID медиа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdMediaMediaIdDelete: async (id: number, mediaId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postsIdMediaMediaIdDelete', 'id', id)
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('postsIdMediaMediaIdDelete', 'mediaId', mediaId)
            const localVarPath = `/posts/{id}/media/{media_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет медиа файл к существующему посту
         * @summary Добавить медиа к посту
         * @param {number} id ID поста
         * @param {File} media Медиа файл (изображение/видео, до 10MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdMediaPost: async (id: number, media: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postsIdMediaPost', 'id', id)
            // verify required parameter 'media' is not null or undefined
            assertParamExists('postsIdMediaPost', 'media', media)
            const localVarPath = `/posts/{id}/media`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (media !== undefined) { 
                localVarFormParams.append('media', media as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет данные поста (только автор может редактировать)
         * @summary Обновить пост
         * @param {number} id ID поста
         * @param {MainUpdatePostRequest} request Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdPatch: async (id: number, request: MainUpdatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postsIdPatch', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('postsIdPatch', 'request', request)
            const localVarPath = `/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новый пост о помощи
         * @summary Создать пост
         * @param {string} title Заголовок
         * @param {string} description Описание
         * @param {number} amount Целевая сумма
         * @param {string} recipient Получатель средств
         * @param {string} bank Банк получателя
         * @param {string} phone Телефон для связи
         * @param {File} [media] Медиа файлы (максимум 10, каждый до 10MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsPost: async (title: string, description: string, amount: number, recipient: string, bank: string, phone: string, media?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'title' is not null or undefined
            assertParamExists('postsPost', 'title', title)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('postsPost', 'description', description)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('postsPost', 'amount', amount)
            // verify required parameter 'recipient' is not null or undefined
            assertParamExists('postsPost', 'recipient', recipient)
            // verify required parameter 'bank' is not null or undefined
            assertParamExists('postsPost', 'bank', bank)
            // verify required parameter 'phone' is not null or undefined
            assertParamExists('postsPost', 'phone', phone)
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (amount !== undefined) { 
                localVarFormParams.append('amount', amount as any);
            }
    
            if (recipient !== undefined) { 
                localVarFormParams.append('recipient', recipient as any);
            }
    
            if (bank !== undefined) { 
                localVarFormParams.append('bank', bank as any);
            }
    
            if (phone !== undefined) { 
                localVarFormParams.append('phone', phone as any);
            }
    
            if (media !== undefined) { 
                localVarFormParams.append('media', media as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает рейтинг пользователей с пагинацией
         * @summary Получить рейтинг пользователей
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGet: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает рейтинг текущего пользователя с позицией
         * @summary Получить свой рейтинг
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ratings/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Генерирует presigned URL для прямой загрузки файла в MinIO
         * @summary Получить presigned URL
         * @param {MainPresignedURLRequest} request Параметры загрузки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPresignedUrlPost: async (request: MainPresignedURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('uploadPresignedUrlPost', 'request', request)
            const localVarPath = `/upload/presigned-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет пароль текущего пользователя
         * @summary Изменить пароль
         * @param {MainChangePasswordRequest} request Старый и новый пароль
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeChangePasswordPost: async (request: MainChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('usersMeChangePasswordPost', 'request', request)
            const localVarPath = `/users/me/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о текущем пользователе
         * @summary Получить профиль
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет данные профиля текущего пользователя
         * @summary Обновить профиль
         * @param {MainUpdateProfileRequest} request Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePatch: async (request: MainUpdateProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('usersMePatch', 'request', request)
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Загружает фото профиля пользователя
         * @summary Загрузить фото профиля
         * @param {File} photo Фото профиля (JPEG, PNG, max 5MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePhotoPost: async (photo: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'photo' is not null or undefined
            assertParamExists('usersMePhotoPost', 'photo', photo)
            const localVarPath = `/users/me/photo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (photo !== undefined) { 
                localVarFormParams.append('photo', photo as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список всех заявок на верификацию с пагинацией
         * @summary Получить список заявок на верификацию
         * @param {VerificationsGetStatusEnum} [status] Фильтр по статусу
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationsGet: async (status?: VerificationsGetStatusEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет статус верификации (одобрить или отклонить)
         * @summary Одобрить/отклонить верификацию
         * @param {number} id ID верификации
         * @param {MainUpdateVerificationRequest} request Статус и причина отклонения
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationsIdPatch: async (id: number, request: MainUpdateVerificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('verificationsIdPatch', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('verificationsIdPatch', 'request', request)
            const localVarPath = `/verifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает статус верификации текущего пользователя
         * @summary Получить статус верификации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationsMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verifications/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает заявку на верификацию пользователя
         * @summary Подать заявку на верификацию
         * @param {File} userPhoto Фото пользователя
         * @param {string} lastName Фамилия
         * @param {string} firstName Имя
         * @param {string} birthDate Дата рождения (YYYY-MM-DD)
         * @param {string} passportSeries Серия паспорта
         * @param {string} passportNumber Номер паспорта
         * @param {string} passportIssuer Кем выдан
         * @param {string} passportDate Дата выдачи (YYYY-MM-DD)
         * @param {VerificationsPostDocTypeEnum} docType Тип документа (inn или snils)
         * @param {File} passportScans Сканы паспорта (минимум 2)
         * @param {boolean} consent1 Согласие 1
         * @param {boolean} consent2 Согласие 2
         * @param {boolean} consent3 Согласие 3
         * @param {string} [middleName] Отчество
         * @param {string} [inn] ИНН
         * @param {string} [snils] СНИЛС
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationsPost: async (userPhoto: File, lastName: string, firstName: string, birthDate: string, passportSeries: string, passportNumber: string, passportIssuer: string, passportDate: string, docType: VerificationsPostDocTypeEnum, passportScans: File, consent1: boolean, consent2: boolean, consent3: boolean, middleName?: string, inn?: string, snils?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPhoto' is not null or undefined
            assertParamExists('verificationsPost', 'userPhoto', userPhoto)
            // verify required parameter 'lastName' is not null or undefined
            assertParamExists('verificationsPost', 'lastName', lastName)
            // verify required parameter 'firstName' is not null or undefined
            assertParamExists('verificationsPost', 'firstName', firstName)
            // verify required parameter 'birthDate' is not null or undefined
            assertParamExists('verificationsPost', 'birthDate', birthDate)
            // verify required parameter 'passportSeries' is not null or undefined
            assertParamExists('verificationsPost', 'passportSeries', passportSeries)
            // verify required parameter 'passportNumber' is not null or undefined
            assertParamExists('verificationsPost', 'passportNumber', passportNumber)
            // verify required parameter 'passportIssuer' is not null or undefined
            assertParamExists('verificationsPost', 'passportIssuer', passportIssuer)
            // verify required parameter 'passportDate' is not null or undefined
            assertParamExists('verificationsPost', 'passportDate', passportDate)
            // verify required parameter 'docType' is not null or undefined
            assertParamExists('verificationsPost', 'docType', docType)
            // verify required parameter 'passportScans' is not null or undefined
            assertParamExists('verificationsPost', 'passportScans', passportScans)
            // verify required parameter 'consent1' is not null or undefined
            assertParamExists('verificationsPost', 'consent1', consent1)
            // verify required parameter 'consent2' is not null or undefined
            assertParamExists('verificationsPost', 'consent2', consent2)
            // verify required parameter 'consent3' is not null or undefined
            assertParamExists('verificationsPost', 'consent3', consent3)
            const localVarPath = `/verifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (userPhoto !== undefined) { 
                localVarFormParams.append('user_photo', userPhoto as any);
            }
    
            if (lastName !== undefined) { 
                localVarFormParams.append('last_name', lastName as any);
            }
    
            if (firstName !== undefined) { 
                localVarFormParams.append('first_name', firstName as any);
            }
    
            if (middleName !== undefined) { 
                localVarFormParams.append('middle_name', middleName as any);
            }
    
            if (birthDate !== undefined) { 
                localVarFormParams.append('birth_date', birthDate as any);
            }
    
            if (passportSeries !== undefined) { 
                localVarFormParams.append('passport_series', passportSeries as any);
            }
    
            if (passportNumber !== undefined) { 
                localVarFormParams.append('passport_number', passportNumber as any);
            }
    
            if (passportIssuer !== undefined) { 
                localVarFormParams.append('passport_issuer', passportIssuer as any);
            }
    
            if (passportDate !== undefined) { 
                localVarFormParams.append('passport_date', passportDate as any);
            }
    
            if (docType !== undefined) { 
                localVarFormParams.append('doc_type', docType as any);
            }
    
            if (inn !== undefined) { 
                localVarFormParams.append('inn', inn as any);
            }
    
            if (snils !== undefined) { 
                localVarFormParams.append('snils', snils as any);
            }
    
            if (passportScans !== undefined) { 
                localVarFormParams.append('passport_scans', passportScans as any);
            }
    
            if (consent1 !== undefined) { 
                localVarFormParams.append('consent1', String(consent1) as any);
            }
    
            if (consent2 !== undefined) { 
                localVarFormParams.append('consent2', String(consent2) as any);
            }
    
            if (consent3 !== undefined) { 
                localVarFormParams.append('consent3', String(consent3) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Аутентифицирует пользователя и возвращает JWT токен
         * @summary Вход в систему
         * @param {MainLoginRequest} request Данные входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(request: MainLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет JWT токен пользователя
         * @summary Обновление токена
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainRefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Регистрирует нового пользователя в системе
         * @summary Регистрация пользователя
         * @param {MainRegisterRequest} request Данные регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(request: MainRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainRegisterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает список всех чатов текущего пользователя
         * @summary Получить список чатов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainChatsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает список сообщений в чате с пагинацией
         * @summary Получить сообщения чата
         * @param {number} id ID чата
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество сообщений
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdMessagesGet(id: number, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainMessagesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdMessagesGet(id, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаляет сообщение из чата (только отправитель может удалить)
         * @summary Удалить сообщение
         * @param {number} id ID чата
         * @param {number} messageId ID сообщения
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdMessagesMessageIdDelete(id: number, messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdMessagesMessageIdDelete(id, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdMessagesMessageIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Редактирует текст сообщения (только отправитель может редактировать)
         * @summary Редактировать сообщение
         * @param {number} id ID чата
         * @param {number} messageId ID сообщения
         * @param {MainUpdateMessageRequest} request Новый текст
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdMessagesMessageIdPatch(id: number, messageId: number, request: MainUpdateMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainMessageUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdMessagesMessageIdPatch(id, messageId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdMessagesMessageIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отправляет новое сообщение в чат (текст или вложение)
         * @summary Отправить сообщение
         * @param {number} id ID чата
         * @param {string} [text] Текст сообщения
         * @param {File} [attachment] Вложение (изображение, до 5MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdMessagesPost(id: number, text?: string, attachment?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdMessagesPost(id, text, attachment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdMessagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отмечает сообщения в чате как прочитанные
         * @summary Отметить сообщения как прочитанные
         * @param {number} id ID чата
         * @param {MainMarkMessagesReadRequest} [request] ID сообщений (опционально, если пусто - все сообщения)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdMessagesReadPatch(id: number, request?: MainMarkMessagesReadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainMarkMessagesReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdMessagesReadPatch(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdMessagesReadPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает новый чат между помощником и нуждающимся по посту
         * @summary Создать чат
         * @param {MainCreateChatRequest} request ID поста
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPost(request: MainCreateChatRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainChatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает список пожертвований с фильтрацией и пагинацией
         * @summary Получить список пожертвований
         * @param {number} [postId] Фильтр по посту
         * @param {number} [donorId] Фильтр по донору
         * @param {DonationsGetStatusEnum} [status] Фильтр по статусу
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async donationsGet(postId?: number, donorId?: number, status?: DonationsGetStatusEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainDonationsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.donationsGet(postId, donorId, status, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.donationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает детальную информацию о пожертвовании
         * @summary Получить пожертвование
         * @param {number} id ID пожертвования
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async donationsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainDonationWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.donationsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.donationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет статус пожертвования (подтвердить или отклонить)
         * @summary Подтвердить/отклонить пожертвование
         * @param {number} id ID пожертвования
         * @param {MainUpdateDonationRequest} request Статус
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async donationsIdPatch(id: number, request: MainUpdateDonationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainDonationUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.donationsIdPatch(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.donationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает новое пожертвование для поста
         * @summary Создать пожертвование
         * @param {number} postId ID поста
         * @param {number} amount Сумма пожертвования
         * @param {File} [receipt] Чек/скриншот (JPEG, PNG, PDF, до 10MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async donationsPost(postId: number, amount: number, receipt?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainDonationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.donationsPost(postId, amount, receipt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.donationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получает файл из MinIO и отдает его клиенту (проксирование). Путь к файлу может содержать слэши, например: /files/user-photos/users/1/photo.jpg
         * @summary Получить файл
         * @param {string} bucket Название bucket
         * @param {string} objectKey Ключ объекта (путь к файлу, может содержать слэши)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesBucketObjectKeyGet(bucket: string, objectKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesBucketObjectKeyGet(bucket, objectKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.filesBucketObjectKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Генерирует presigned URL для чтения (скачивания) файла из MinIO
         * @summary Получить presigned URL для чтения
         * @param {MainPresignedGetURLRequest} request Параметры запроса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesPresignedUrlPost(request: MainPresignedGetURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPresignedGetURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesPresignedUrlPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.filesPresignedUrlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Проверяет состояние сервера, подключение к базе данных и MinIO
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainHealthCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает список постов с пагинацией и фильтрацией
         * @summary Получить список постов
         * @param {PostsGetStatusEnum} [status] Фильтр по статусу
         * @param {number} [userId] Фильтр по автору
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsGet(status?: PostsGetStatusEnum, userId?: number, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPostsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postsGet(status, userId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаляет пост (только автор может удалить)
         * @summary Удалить пост
         * @param {number} id ID поста
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает детальную информацию о посте
         * @summary Получить пост
         * @param {number} id ID поста
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPostWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаляет медиа файл из поста
         * @summary Удалить медиа из поста
         * @param {number} id ID поста
         * @param {number} mediaId ID медиа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsIdMediaMediaIdDelete(id: number, mediaId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postsIdMediaMediaIdDelete(id, mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postsIdMediaMediaIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Добавляет медиа файл к существующему посту
         * @summary Добавить медиа к посту
         * @param {number} id ID поста
         * @param {File} media Медиа файл (изображение/видео, до 10MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsIdMediaPost(id: number, media: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPostMedia>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postsIdMediaPost(id, media, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postsIdMediaPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет данные поста (только автор может редактировать)
         * @summary Обновить пост
         * @param {number} id ID поста
         * @param {MainUpdatePostRequest} request Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsIdPatch(id: number, request: MainUpdatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPostUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postsIdPatch(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает новый пост о помощи
         * @summary Создать пост
         * @param {string} title Заголовок
         * @param {string} description Описание
         * @param {number} amount Целевая сумма
         * @param {string} recipient Получатель средств
         * @param {string} bank Банк получателя
         * @param {string} phone Телефон для связи
         * @param {File} [media] Медиа файлы (максимум 10, каждый до 10MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsPost(title: string, description: string, amount: number, recipient: string, bank: string, phone: string, media?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postsPost(title, description, amount, recipient, bank, phone, media, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает рейтинг пользователей с пагинацией
         * @summary Получить рейтинг пользователей
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingsGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainRatingsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratingsGet(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.ratingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает рейтинг текущего пользователя с позицией
         * @summary Получить свой рейтинг
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingsMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainRatingWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratingsMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.ratingsMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Генерирует presigned URL для прямой загрузки файла в MinIO
         * @summary Получить presigned URL
         * @param {MainPresignedURLRequest} request Параметры загрузки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPresignedUrlPost(request: MainPresignedURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPresignedURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPresignedUrlPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadPresignedUrlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Изменяет пароль текущего пользователя
         * @summary Изменить пароль
         * @param {MainChangePasswordRequest} request Старый и новый пароль
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeChangePasswordPost(request: MainChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeChangePasswordPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersMeChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает информацию о текущем пользователе
         * @summary Получить профиль
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет данные профиля текущего пользователя
         * @summary Обновить профиль
         * @param {MainUpdateProfileRequest} request Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMePatch(request: MainUpdateProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMePatch(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersMePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Загружает фото профиля пользователя
         * @summary Загрузить фото профиля
         * @param {File} photo Фото профиля (JPEG, PNG, max 5MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMePhotoPost(photo: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPhotoUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMePhotoPost(photo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersMePhotoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает список всех заявок на верификацию с пагинацией
         * @summary Получить список заявок на верификацию
         * @param {VerificationsGetStatusEnum} [status] Фильтр по статусу
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verificationsGet(status?: VerificationsGetStatusEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainVerificationsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verificationsGet(status, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verificationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет статус верификации (одобрить или отклонить)
         * @summary Одобрить/отклонить верификацию
         * @param {number} id ID верификации
         * @param {MainUpdateVerificationRequest} request Статус и причина отклонения
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verificationsIdPatch(id: number, request: MainUpdateVerificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verificationsIdPatch(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verificationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает статус верификации текущего пользователя
         * @summary Получить статус верификации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verificationsMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verificationsMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verificationsMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает заявку на верификацию пользователя
         * @summary Подать заявку на верификацию
         * @param {File} userPhoto Фото пользователя
         * @param {string} lastName Фамилия
         * @param {string} firstName Имя
         * @param {string} birthDate Дата рождения (YYYY-MM-DD)
         * @param {string} passportSeries Серия паспорта
         * @param {string} passportNumber Номер паспорта
         * @param {string} passportIssuer Кем выдан
         * @param {string} passportDate Дата выдачи (YYYY-MM-DD)
         * @param {VerificationsPostDocTypeEnum} docType Тип документа (inn или snils)
         * @param {File} passportScans Сканы паспорта (минимум 2)
         * @param {boolean} consent1 Согласие 1
         * @param {boolean} consent2 Согласие 2
         * @param {boolean} consent3 Согласие 3
         * @param {string} [middleName] Отчество
         * @param {string} [inn] ИНН
         * @param {string} [snils] СНИЛС
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verificationsPost(userPhoto: File, lastName: string, firstName: string, birthDate: string, passportSeries: string, passportNumber: string, passportIssuer: string, passportDate: string, docType: VerificationsPostDocTypeEnum, passportScans: File, consent1: boolean, consent2: boolean, consent3: boolean, middleName?: string, inn?: string, snils?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verificationsPost(userPhoto, lastName, firstName, birthDate, passportSeries, passportNumber, passportIssuer, passportDate, docType, passportScans, consent1, consent2, consent3, middleName, inn, snils, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verificationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Аутентифицирует пользователя и возвращает JWT токен
         * @summary Вход в систему
         * @param {MainLoginRequest} request Данные входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(request: MainLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainLoginResponse> {
            return localVarFp.authLoginPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет JWT токен пользователя
         * @summary Обновление токена
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshPost(options?: RawAxiosRequestConfig): AxiosPromise<MainRefreshTokenResponse> {
            return localVarFp.authRefreshPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Регистрирует нового пользователя в системе
         * @summary Регистрация пользователя
         * @param {MainRegisterRequest} request Данные регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(request: MainRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainRegisterResponse> {
            return localVarFp.authRegisterPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает список всех чатов текущего пользователя
         * @summary Получить список чатов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet(options?: RawAxiosRequestConfig): AxiosPromise<MainChatsListResponse> {
            return localVarFp.chatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает список сообщений в чате с пагинацией
         * @summary Получить сообщения чата
         * @param {number} id ID чата
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество сообщений
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesGet(id: number, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainMessagesListResponse> {
            return localVarFp.chatsIdMessagesGet(id, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Удаляет сообщение из чата (только отправитель может удалить)
         * @summary Удалить сообщение
         * @param {number} id ID чата
         * @param {number} messageId ID сообщения
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesMessageIdDelete(id: number, messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.chatsIdMessagesMessageIdDelete(id, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Редактирует текст сообщения (только отправитель может редактировать)
         * @summary Редактировать сообщение
         * @param {number} id ID чата
         * @param {number} messageId ID сообщения
         * @param {MainUpdateMessageRequest} request Новый текст
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesMessageIdPatch(id: number, messageId: number, request: MainUpdateMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainMessageUpdateResponse> {
            return localVarFp.chatsIdMessagesMessageIdPatch(id, messageId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Отправляет новое сообщение в чат (текст или вложение)
         * @summary Отправить сообщение
         * @param {number} id ID чата
         * @param {string} [text] Текст сообщения
         * @param {File} [attachment] Вложение (изображение, до 5MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesPost(id: number, text?: string, attachment?: File, options?: RawAxiosRequestConfig): AxiosPromise<MainMessageResponse> {
            return localVarFp.chatsIdMessagesPost(id, text, attachment, options).then((request) => request(axios, basePath));
        },
        /**
         * Отмечает сообщения в чате как прочитанные
         * @summary Отметить сообщения как прочитанные
         * @param {number} id ID чата
         * @param {MainMarkMessagesReadRequest} [request] ID сообщений (опционально, если пусто - все сообщения)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesReadPatch(id: number, request?: MainMarkMessagesReadRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainMarkMessagesReadResponse> {
            return localVarFp.chatsIdMessagesReadPatch(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Создает новый чат между помощником и нуждающимся по посту
         * @summary Создать чат
         * @param {MainCreateChatRequest} request ID поста
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPost(request: MainCreateChatRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainChatResponse> {
            return localVarFp.chatsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает список пожертвований с фильтрацией и пагинацией
         * @summary Получить список пожертвований
         * @param {number} [postId] Фильтр по посту
         * @param {number} [donorId] Фильтр по донору
         * @param {DonationsGetStatusEnum} [status] Фильтр по статусу
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        donationsGet(postId?: number, donorId?: number, status?: DonationsGetStatusEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainDonationsListResponse> {
            return localVarFp.donationsGet(postId, donorId, status, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает детальную информацию о пожертвовании
         * @summary Получить пожертвование
         * @param {number} id ID пожертвования
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        donationsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MainDonationWithDetails> {
            return localVarFp.donationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет статус пожертвования (подтвердить или отклонить)
         * @summary Подтвердить/отклонить пожертвование
         * @param {number} id ID пожертвования
         * @param {MainUpdateDonationRequest} request Статус
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        donationsIdPatch(id: number, request: MainUpdateDonationRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainDonationUpdateResponse> {
            return localVarFp.donationsIdPatch(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Создает новое пожертвование для поста
         * @summary Создать пожертвование
         * @param {number} postId ID поста
         * @param {number} amount Сумма пожертвования
         * @param {File} [receipt] Чек/скриншот (JPEG, PNG, PDF, до 10MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        donationsPost(postId: number, amount: number, receipt?: File, options?: RawAxiosRequestConfig): AxiosPromise<MainDonationResponse> {
            return localVarFp.donationsPost(postId, amount, receipt, options).then((request) => request(axios, basePath));
        },
        /**
         * Получает файл из MinIO и отдает его клиенту (проксирование). Путь к файлу может содержать слэши, например: /files/user-photos/users/1/photo.jpg
         * @summary Получить файл
         * @param {string} bucket Название bucket
         * @param {string} objectKey Ключ объекта (путь к файлу, может содержать слэши)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesBucketObjectKeyGet(bucket: string, objectKey: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.filesBucketObjectKeyGet(bucket, objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Генерирует presigned URL для чтения (скачивания) файла из MinIO
         * @summary Получить presigned URL для чтения
         * @param {MainPresignedGetURLRequest} request Параметры запроса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPresignedUrlPost(request: MainPresignedGetURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainPresignedGetURLResponse> {
            return localVarFp.filesPresignedUrlPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Проверяет состояние сервера, подключение к базе данных и MinIO
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: RawAxiosRequestConfig): AxiosPromise<MainHealthCheckResponse> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает список постов с пагинацией и фильтрацией
         * @summary Получить список постов
         * @param {PostsGetStatusEnum} [status] Фильтр по статусу
         * @param {number} [userId] Фильтр по автору
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsGet(status?: PostsGetStatusEnum, userId?: number, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainPostsListResponse> {
            return localVarFp.postsGet(status, userId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Удаляет пост (только автор может удалить)
         * @summary Удалить пост
         * @param {number} id ID поста
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает детальную информацию о посте
         * @summary Получить пост
         * @param {number} id ID поста
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MainPostWithDetails> {
            return localVarFp.postsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Удаляет медиа файл из поста
         * @summary Удалить медиа из поста
         * @param {number} id ID поста
         * @param {number} mediaId ID медиа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdMediaMediaIdDelete(id: number, mediaId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postsIdMediaMediaIdDelete(id, mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Добавляет медиа файл к существующему посту
         * @summary Добавить медиа к посту
         * @param {number} id ID поста
         * @param {File} media Медиа файл (изображение/видео, до 10MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdMediaPost(id: number, media: File, options?: RawAxiosRequestConfig): AxiosPromise<MainPostMedia> {
            return localVarFp.postsIdMediaPost(id, media, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет данные поста (только автор может редактировать)
         * @summary Обновить пост
         * @param {number} id ID поста
         * @param {MainUpdatePostRequest} request Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsIdPatch(id: number, request: MainUpdatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainPostUpdateResponse> {
            return localVarFp.postsIdPatch(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Создает новый пост о помощи
         * @summary Создать пост
         * @param {string} title Заголовок
         * @param {string} description Описание
         * @param {number} amount Целевая сумма
         * @param {string} recipient Получатель средств
         * @param {string} bank Банк получателя
         * @param {string} phone Телефон для связи
         * @param {File} [media] Медиа файлы (максимум 10, каждый до 10MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsPost(title: string, description: string, amount: number, recipient: string, bank: string, phone: string, media?: File, options?: RawAxiosRequestConfig): AxiosPromise<MainPostResponse> {
            return localVarFp.postsPost(title, description, amount, recipient, bank, phone, media, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает рейтинг пользователей с пагинацией
         * @summary Получить рейтинг пользователей
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainRatingsListResponse> {
            return localVarFp.ratingsGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает рейтинг текущего пользователя с позицией
         * @summary Получить свой рейтинг
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsMeGet(options?: RawAxiosRequestConfig): AxiosPromise<MainRatingWithDetails> {
            return localVarFp.ratingsMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Генерирует presigned URL для прямой загрузки файла в MinIO
         * @summary Получить presigned URL
         * @param {MainPresignedURLRequest} request Параметры загрузки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPresignedUrlPost(request: MainPresignedURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainPresignedURLResponse> {
            return localVarFp.uploadPresignedUrlPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Изменяет пароль текущего пользователя
         * @summary Изменить пароль
         * @param {MainChangePasswordRequest} request Старый и новый пароль
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeChangePasswordPost(request: MainChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainSuccessResponse> {
            return localVarFp.usersMeChangePasswordPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает информацию о текущем пользователе
         * @summary Получить профиль
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: RawAxiosRequestConfig): AxiosPromise<MainUser> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет данные профиля текущего пользователя
         * @summary Обновить профиль
         * @param {MainUpdateProfileRequest} request Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePatch(request: MainUpdateProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainUser> {
            return localVarFp.usersMePatch(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Загружает фото профиля пользователя
         * @summary Загрузить фото профиля
         * @param {File} photo Фото профиля (JPEG, PNG, max 5MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePhotoPost(photo: File, options?: RawAxiosRequestConfig): AxiosPromise<MainPhotoUploadResponse> {
            return localVarFp.usersMePhotoPost(photo, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает список всех заявок на верификацию с пагинацией
         * @summary Получить список заявок на верификацию
         * @param {VerificationsGetStatusEnum} [status] Фильтр по статусу
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationsGet(status?: VerificationsGetStatusEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainVerificationsListResponse> {
            return localVarFp.verificationsGet(status, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет статус верификации (одобрить или отклонить)
         * @summary Одобрить/отклонить верификацию
         * @param {number} id ID верификации
         * @param {MainUpdateVerificationRequest} request Статус и причина отклонения
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationsIdPatch(id: number, request: MainUpdateVerificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainVerificationResponse> {
            return localVarFp.verificationsIdPatch(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает статус верификации текущего пользователя
         * @summary Получить статус верификации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationsMeGet(options?: RawAxiosRequestConfig): AxiosPromise<MainVerificationResponse> {
            return localVarFp.verificationsMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Создает заявку на верификацию пользователя
         * @summary Подать заявку на верификацию
         * @param {File} userPhoto Фото пользователя
         * @param {string} lastName Фамилия
         * @param {string} firstName Имя
         * @param {string} birthDate Дата рождения (YYYY-MM-DD)
         * @param {string} passportSeries Серия паспорта
         * @param {string} passportNumber Номер паспорта
         * @param {string} passportIssuer Кем выдан
         * @param {string} passportDate Дата выдачи (YYYY-MM-DD)
         * @param {VerificationsPostDocTypeEnum} docType Тип документа (inn или snils)
         * @param {File} passportScans Сканы паспорта (минимум 2)
         * @param {boolean} consent1 Согласие 1
         * @param {boolean} consent2 Согласие 2
         * @param {boolean} consent3 Согласие 3
         * @param {string} [middleName] Отчество
         * @param {string} [inn] ИНН
         * @param {string} [snils] СНИЛС
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationsPost(userPhoto: File, lastName: string, firstName: string, birthDate: string, passportSeries: string, passportNumber: string, passportIssuer: string, passportDate: string, docType: VerificationsPostDocTypeEnum, passportScans: File, consent1: boolean, consent2: boolean, consent3: boolean, middleName?: string, inn?: string, snils?: string, options?: RawAxiosRequestConfig): AxiosPromise<MainVerificationResponse> {
            return localVarFp.verificationsPost(userPhoto, lastName, firstName, birthDate, passportSeries, passportNumber, passportIssuer, passportDate, docType, passportScans, consent1, consent2, consent3, middleName, inn, snils, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 */
export interface DefaultApiInterface {
    /**
     * Аутентифицирует пользователя и возвращает JWT токен
     * @summary Вход в систему
     * @param {MainLoginRequest} request Данные входа
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLoginPost(request: MainLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainLoginResponse>;

    /**
     * Обновляет JWT токен пользователя
     * @summary Обновление токена
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authRefreshPost(options?: RawAxiosRequestConfig): AxiosPromise<MainRefreshTokenResponse>;

    /**
     * Регистрирует нового пользователя в системе
     * @summary Регистрация пользователя
     * @param {MainRegisterRequest} request Данные регистрации
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authRegisterPost(request: MainRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainRegisterResponse>;

    /**
     * Возвращает список всех чатов текущего пользователя
     * @summary Получить список чатов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsGet(options?: RawAxiosRequestConfig): AxiosPromise<MainChatsListResponse>;

    /**
     * Возвращает список сообщений в чате с пагинацией
     * @summary Получить сообщения чата
     * @param {number} id ID чата
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество сообщений
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdMessagesGet(id: number, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainMessagesListResponse>;

    /**
     * Удаляет сообщение из чата (только отправитель может удалить)
     * @summary Удалить сообщение
     * @param {number} id ID чата
     * @param {number} messageId ID сообщения
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdMessagesMessageIdDelete(id: number, messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Редактирует текст сообщения (только отправитель может редактировать)
     * @summary Редактировать сообщение
     * @param {number} id ID чата
     * @param {number} messageId ID сообщения
     * @param {MainUpdateMessageRequest} request Новый текст
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdMessagesMessageIdPatch(id: number, messageId: number, request: MainUpdateMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainMessageUpdateResponse>;

    /**
     * Отправляет новое сообщение в чат (текст или вложение)
     * @summary Отправить сообщение
     * @param {number} id ID чата
     * @param {string} [text] Текст сообщения
     * @param {File} [attachment] Вложение (изображение, до 5MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdMessagesPost(id: number, text?: string, attachment?: File, options?: RawAxiosRequestConfig): AxiosPromise<MainMessageResponse>;

    /**
     * Отмечает сообщения в чате как прочитанные
     * @summary Отметить сообщения как прочитанные
     * @param {number} id ID чата
     * @param {MainMarkMessagesReadRequest} [request] ID сообщений (опционально, если пусто - все сообщения)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdMessagesReadPatch(id: number, request?: MainMarkMessagesReadRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainMarkMessagesReadResponse>;

    /**
     * Создает новый чат между помощником и нуждающимся по посту
     * @summary Создать чат
     * @param {MainCreateChatRequest} request ID поста
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsPost(request: MainCreateChatRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainChatResponse>;

    /**
     * Возвращает список пожертвований с фильтрацией и пагинацией
     * @summary Получить список пожертвований
     * @param {number} [postId] Фильтр по посту
     * @param {number} [donorId] Фильтр по донору
     * @param {DonationsGetStatusEnum} [status] Фильтр по статусу
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество на странице
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    donationsGet(postId?: number, donorId?: number, status?: DonationsGetStatusEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainDonationsListResponse>;

    /**
     * Возвращает детальную информацию о пожертвовании
     * @summary Получить пожертвование
     * @param {number} id ID пожертвования
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    donationsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MainDonationWithDetails>;

    /**
     * Обновляет статус пожертвования (подтвердить или отклонить)
     * @summary Подтвердить/отклонить пожертвование
     * @param {number} id ID пожертвования
     * @param {MainUpdateDonationRequest} request Статус
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    donationsIdPatch(id: number, request: MainUpdateDonationRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainDonationUpdateResponse>;

    /**
     * Создает новое пожертвование для поста
     * @summary Создать пожертвование
     * @param {number} postId ID поста
     * @param {number} amount Сумма пожертвования
     * @param {File} [receipt] Чек/скриншот (JPEG, PNG, PDF, до 10MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    donationsPost(postId: number, amount: number, receipt?: File, options?: RawAxiosRequestConfig): AxiosPromise<MainDonationResponse>;

    /**
     * Получает файл из MinIO и отдает его клиенту (проксирование). Путь к файлу может содержать слэши, например: /files/user-photos/users/1/photo.jpg
     * @summary Получить файл
     * @param {string} bucket Название bucket
     * @param {string} objectKey Ключ объекта (путь к файлу, может содержать слэши)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesBucketObjectKeyGet(bucket: string, objectKey: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Генерирует presigned URL для чтения (скачивания) файла из MinIO
     * @summary Получить presigned URL для чтения
     * @param {MainPresignedGetURLRequest} request Параметры запроса
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesPresignedUrlPost(request: MainPresignedGetURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainPresignedGetURLResponse>;

    /**
     * Проверяет состояние сервера, подключение к базе данных и MinIO
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthGet(options?: RawAxiosRequestConfig): AxiosPromise<MainHealthCheckResponse>;

    /**
     * Возвращает список постов с пагинацией и фильтрацией
     * @summary Получить список постов
     * @param {PostsGetStatusEnum} [status] Фильтр по статусу
     * @param {number} [userId] Фильтр по автору
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество на странице
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsGet(status?: PostsGetStatusEnum, userId?: number, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainPostsListResponse>;

    /**
     * Удаляет пост (только автор может удалить)
     * @summary Удалить пост
     * @param {number} id ID поста
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Возвращает детальную информацию о посте
     * @summary Получить пост
     * @param {number} id ID поста
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MainPostWithDetails>;

    /**
     * Удаляет медиа файл из поста
     * @summary Удалить медиа из поста
     * @param {number} id ID поста
     * @param {number} mediaId ID медиа
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdMediaMediaIdDelete(id: number, mediaId: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Добавляет медиа файл к существующему посту
     * @summary Добавить медиа к посту
     * @param {number} id ID поста
     * @param {File} media Медиа файл (изображение/видео, до 10MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdMediaPost(id: number, media: File, options?: RawAxiosRequestConfig): AxiosPromise<MainPostMedia>;

    /**
     * Обновляет данные поста (только автор может редактировать)
     * @summary Обновить пост
     * @param {number} id ID поста
     * @param {MainUpdatePostRequest} request Данные для обновления
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdPatch(id: number, request: MainUpdatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainPostUpdateResponse>;

    /**
     * Создает новый пост о помощи
     * @summary Создать пост
     * @param {string} title Заголовок
     * @param {string} description Описание
     * @param {number} amount Целевая сумма
     * @param {string} recipient Получатель средств
     * @param {string} bank Банк получателя
     * @param {string} phone Телефон для связи
     * @param {File} [media] Медиа файлы (максимум 10, каждый до 10MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsPost(title: string, description: string, amount: number, recipient: string, bank: string, phone: string, media?: File, options?: RawAxiosRequestConfig): AxiosPromise<MainPostResponse>;

    /**
     * Возвращает рейтинг пользователей с пагинацией
     * @summary Получить рейтинг пользователей
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество на странице
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ratingsGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainRatingsListResponse>;

    /**
     * Возвращает рейтинг текущего пользователя с позицией
     * @summary Получить свой рейтинг
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ratingsMeGet(options?: RawAxiosRequestConfig): AxiosPromise<MainRatingWithDetails>;

    /**
     * Генерирует presigned URL для прямой загрузки файла в MinIO
     * @summary Получить presigned URL
     * @param {MainPresignedURLRequest} request Параметры загрузки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPresignedUrlPost(request: MainPresignedURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainPresignedURLResponse>;

    /**
     * Изменяет пароль текущего пользователя
     * @summary Изменить пароль
     * @param {MainChangePasswordRequest} request Старый и новый пароль
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMeChangePasswordPost(request: MainChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainSuccessResponse>;

    /**
     * Возвращает информацию о текущем пользователе
     * @summary Получить профиль
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMeGet(options?: RawAxiosRequestConfig): AxiosPromise<MainUser>;

    /**
     * Обновляет данные профиля текущего пользователя
     * @summary Обновить профиль
     * @param {MainUpdateProfileRequest} request Данные для обновления
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMePatch(request: MainUpdateProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainUser>;

    /**
     * Загружает фото профиля пользователя
     * @summary Загрузить фото профиля
     * @param {File} photo Фото профиля (JPEG, PNG, max 5MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMePhotoPost(photo: File, options?: RawAxiosRequestConfig): AxiosPromise<MainPhotoUploadResponse>;

    /**
     * Возвращает список всех заявок на верификацию с пагинацией
     * @summary Получить список заявок на верификацию
     * @param {VerificationsGetStatusEnum} [status] Фильтр по статусу
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество на странице
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationsGet(status?: VerificationsGetStatusEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<MainVerificationsListResponse>;

    /**
     * Обновляет статус верификации (одобрить или отклонить)
     * @summary Одобрить/отклонить верификацию
     * @param {number} id ID верификации
     * @param {MainUpdateVerificationRequest} request Статус и причина отклонения
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationsIdPatch(id: number, request: MainUpdateVerificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainVerificationResponse>;

    /**
     * Возвращает статус верификации текущего пользователя
     * @summary Получить статус верификации
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationsMeGet(options?: RawAxiosRequestConfig): AxiosPromise<MainVerificationResponse>;

    /**
     * Создает заявку на верификацию пользователя
     * @summary Подать заявку на верификацию
     * @param {File} userPhoto Фото пользователя
     * @param {string} lastName Фамилия
     * @param {string} firstName Имя
     * @param {string} birthDate Дата рождения (YYYY-MM-DD)
     * @param {string} passportSeries Серия паспорта
     * @param {string} passportNumber Номер паспорта
     * @param {string} passportIssuer Кем выдан
     * @param {string} passportDate Дата выдачи (YYYY-MM-DD)
     * @param {VerificationsPostDocTypeEnum} docType Тип документа (inn или snils)
     * @param {File} passportScans Сканы паспорта (минимум 2)
     * @param {boolean} consent1 Согласие 1
     * @param {boolean} consent2 Согласие 2
     * @param {boolean} consent3 Согласие 3
     * @param {string} [middleName] Отчество
     * @param {string} [inn] ИНН
     * @param {string} [snils] СНИЛС
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationsPost(userPhoto: File, lastName: string, firstName: string, birthDate: string, passportSeries: string, passportNumber: string, passportIssuer: string, passportDate: string, docType: VerificationsPostDocTypeEnum, passportScans: File, consent1: boolean, consent2: boolean, consent3: boolean, middleName?: string, inn?: string, snils?: string, options?: RawAxiosRequestConfig): AxiosPromise<MainVerificationResponse>;

}

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Аутентифицирует пользователя и возвращает JWT токен
     * @summary Вход в систему
     * @param {MainLoginRequest} request Данные входа
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authLoginPost(request: MainLoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authLoginPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет JWT токен пользователя
     * @summary Обновление токена
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authRefreshPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authRefreshPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Регистрирует нового пользователя в системе
     * @summary Регистрация пользователя
     * @param {MainRegisterRequest} request Данные регистрации
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authRegisterPost(request: MainRegisterRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authRegisterPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает список всех чатов текущего пользователя
     * @summary Получить список чатов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public chatsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает список сообщений в чате с пагинацией
     * @summary Получить сообщения чата
     * @param {number} id ID чата
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество сообщений
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public chatsIdMessagesGet(id: number, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdMessagesGet(id, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаляет сообщение из чата (только отправитель может удалить)
     * @summary Удалить сообщение
     * @param {number} id ID чата
     * @param {number} messageId ID сообщения
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public chatsIdMessagesMessageIdDelete(id: number, messageId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdMessagesMessageIdDelete(id, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Редактирует текст сообщения (только отправитель может редактировать)
     * @summary Редактировать сообщение
     * @param {number} id ID чата
     * @param {number} messageId ID сообщения
     * @param {MainUpdateMessageRequest} request Новый текст
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public chatsIdMessagesMessageIdPatch(id: number, messageId: number, request: MainUpdateMessageRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdMessagesMessageIdPatch(id, messageId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отправляет новое сообщение в чат (текст или вложение)
     * @summary Отправить сообщение
     * @param {number} id ID чата
     * @param {string} [text] Текст сообщения
     * @param {File} [attachment] Вложение (изображение, до 5MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public chatsIdMessagesPost(id: number, text?: string, attachment?: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdMessagesPost(id, text, attachment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отмечает сообщения в чате как прочитанные
     * @summary Отметить сообщения как прочитанные
     * @param {number} id ID чата
     * @param {MainMarkMessagesReadRequest} [request] ID сообщений (опционально, если пусто - все сообщения)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public chatsIdMessagesReadPatch(id: number, request?: MainMarkMessagesReadRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdMessagesReadPatch(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает новый чат между помощником и нуждающимся по посту
     * @summary Создать чат
     * @param {MainCreateChatRequest} request ID поста
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public chatsPost(request: MainCreateChatRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает список пожертвований с фильтрацией и пагинацией
     * @summary Получить список пожертвований
     * @param {number} [postId] Фильтр по посту
     * @param {number} [donorId] Фильтр по донору
     * @param {DonationsGetStatusEnum} [status] Фильтр по статусу
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество на странице
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public donationsGet(postId?: number, donorId?: number, status?: DonationsGetStatusEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).donationsGet(postId, donorId, status, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает детальную информацию о пожертвовании
     * @summary Получить пожертвование
     * @param {number} id ID пожертвования
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public donationsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).donationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет статус пожертвования (подтвердить или отклонить)
     * @summary Подтвердить/отклонить пожертвование
     * @param {number} id ID пожертвования
     * @param {MainUpdateDonationRequest} request Статус
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public donationsIdPatch(id: number, request: MainUpdateDonationRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).donationsIdPatch(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает новое пожертвование для поста
     * @summary Создать пожертвование
     * @param {number} postId ID поста
     * @param {number} amount Сумма пожертвования
     * @param {File} [receipt] Чек/скриншот (JPEG, PNG, PDF, до 10MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public donationsPost(postId: number, amount: number, receipt?: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).donationsPost(postId, amount, receipt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получает файл из MinIO и отдает его клиенту (проксирование). Путь к файлу может содержать слэши, например: /files/user-photos/users/1/photo.jpg
     * @summary Получить файл
     * @param {string} bucket Название bucket
     * @param {string} objectKey Ключ объекта (путь к файлу, может содержать слэши)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filesBucketObjectKeyGet(bucket: string, objectKey: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).filesBucketObjectKeyGet(bucket, objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Генерирует presigned URL для чтения (скачивания) файла из MinIO
     * @summary Получить presigned URL для чтения
     * @param {MainPresignedGetURLRequest} request Параметры запроса
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filesPresignedUrlPost(request: MainPresignedGetURLRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).filesPresignedUrlPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Проверяет состояние сервера, подключение к базе данных и MinIO
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает список постов с пагинацией и фильтрацией
     * @summary Получить список постов
     * @param {PostsGetStatusEnum} [status] Фильтр по статусу
     * @param {number} [userId] Фильтр по автору
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество на странице
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postsGet(status?: PostsGetStatusEnum, userId?: number, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postsGet(status, userId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаляет пост (только автор может удалить)
     * @summary Удалить пост
     * @param {number} id ID поста
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает детальную информацию о посте
     * @summary Получить пост
     * @param {number} id ID поста
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаляет медиа файл из поста
     * @summary Удалить медиа из поста
     * @param {number} id ID поста
     * @param {number} mediaId ID медиа
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postsIdMediaMediaIdDelete(id: number, mediaId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postsIdMediaMediaIdDelete(id, mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Добавляет медиа файл к существующему посту
     * @summary Добавить медиа к посту
     * @param {number} id ID поста
     * @param {File} media Медиа файл (изображение/видео, до 10MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postsIdMediaPost(id: number, media: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postsIdMediaPost(id, media, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет данные поста (только автор может редактировать)
     * @summary Обновить пост
     * @param {number} id ID поста
     * @param {MainUpdatePostRequest} request Данные для обновления
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postsIdPatch(id: number, request: MainUpdatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postsIdPatch(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает новый пост о помощи
     * @summary Создать пост
     * @param {string} title Заголовок
     * @param {string} description Описание
     * @param {number} amount Целевая сумма
     * @param {string} recipient Получатель средств
     * @param {string} bank Банк получателя
     * @param {string} phone Телефон для связи
     * @param {File} [media] Медиа файлы (максимум 10, каждый до 10MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postsPost(title: string, description: string, amount: number, recipient: string, bank: string, phone: string, media?: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postsPost(title, description, amount, recipient, bank, phone, media, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает рейтинг пользователей с пагинацией
     * @summary Получить рейтинг пользователей
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество на странице
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ratingsGet(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).ratingsGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает рейтинг текущего пользователя с позицией
     * @summary Получить свой рейтинг
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ratingsMeGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).ratingsMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Генерирует presigned URL для прямой загрузки файла в MinIO
     * @summary Получить presigned URL
     * @param {MainPresignedURLRequest} request Параметры загрузки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadPresignedUrlPost(request: MainPresignedURLRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadPresignedUrlPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Изменяет пароль текущего пользователя
     * @summary Изменить пароль
     * @param {MainChangePasswordRequest} request Старый и новый пароль
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersMeChangePasswordPost(request: MainChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersMeChangePasswordPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает информацию о текущем пользователе
     * @summary Получить профиль
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersMeGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет данные профиля текущего пользователя
     * @summary Обновить профиль
     * @param {MainUpdateProfileRequest} request Данные для обновления
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersMePatch(request: MainUpdateProfileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersMePatch(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Загружает фото профиля пользователя
     * @summary Загрузить фото профиля
     * @param {File} photo Фото профиля (JPEG, PNG, max 5MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersMePhotoPost(photo: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersMePhotoPost(photo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает список всех заявок на верификацию с пагинацией
     * @summary Получить список заявок на верификацию
     * @param {VerificationsGetStatusEnum} [status] Фильтр по статусу
     * @param {number} [page] Номер страницы
     * @param {number} [limit] Количество на странице
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verificationsGet(status?: VerificationsGetStatusEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verificationsGet(status, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет статус верификации (одобрить или отклонить)
     * @summary Одобрить/отклонить верификацию
     * @param {number} id ID верификации
     * @param {MainUpdateVerificationRequest} request Статус и причина отклонения
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verificationsIdPatch(id: number, request: MainUpdateVerificationRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verificationsIdPatch(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает статус верификации текущего пользователя
     * @summary Получить статус верификации
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verificationsMeGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verificationsMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает заявку на верификацию пользователя
     * @summary Подать заявку на верификацию
     * @param {File} userPhoto Фото пользователя
     * @param {string} lastName Фамилия
     * @param {string} firstName Имя
     * @param {string} birthDate Дата рождения (YYYY-MM-DD)
     * @param {string} passportSeries Серия паспорта
     * @param {string} passportNumber Номер паспорта
     * @param {string} passportIssuer Кем выдан
     * @param {string} passportDate Дата выдачи (YYYY-MM-DD)
     * @param {VerificationsPostDocTypeEnum} docType Тип документа (inn или snils)
     * @param {File} passportScans Сканы паспорта (минимум 2)
     * @param {boolean} consent1 Согласие 1
     * @param {boolean} consent2 Согласие 2
     * @param {boolean} consent3 Согласие 3
     * @param {string} [middleName] Отчество
     * @param {string} [inn] ИНН
     * @param {string} [snils] СНИЛС
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verificationsPost(userPhoto: File, lastName: string, firstName: string, birthDate: string, passportSeries: string, passportNumber: string, passportIssuer: string, passportDate: string, docType: VerificationsPostDocTypeEnum, passportScans: File, consent1: boolean, consent2: boolean, consent3: boolean, middleName?: string, inn?: string, snils?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verificationsPost(userPhoto, lastName, firstName, birthDate, passportSeries, passportNumber, passportIssuer, passportDate, docType, passportScans, consent1, consent2, consent3, middleName, inn, snils, options).then((request) => request(this.axios, this.basePath));
    }
}

export const DonationsGetStatusEnum = {
    Pending: 'pending',
    Confirmed: 'confirmed',
    Rejected: 'rejected'
} as const;
export type DonationsGetStatusEnum = typeof DonationsGetStatusEnum[keyof typeof DonationsGetStatusEnum];
export const PostsGetStatusEnum = {
    Active: 'active',
    Completed: 'completed',
    Closed: 'closed',
    Moderated: 'moderated'
} as const;
export type PostsGetStatusEnum = typeof PostsGetStatusEnum[keyof typeof PostsGetStatusEnum];
export const VerificationsGetStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;
export type VerificationsGetStatusEnum = typeof VerificationsGetStatusEnum[keyof typeof VerificationsGetStatusEnum];
export const VerificationsPostDocTypeEnum = {
    Inn: 'inn',
    Snils: 'snils'
} as const;
export type VerificationsPostDocTypeEnum = typeof VerificationsPostDocTypeEnum[keyof typeof VerificationsPostDocTypeEnum];


